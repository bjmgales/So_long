/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   so_long.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: bgales <bgales@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2022/05/18 10:53:29 by bgales            #+#    #+#             */
/*   Updated: 2023/04/28 18:10:27 by bgales           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "so_long.h"

char	**get_map(const char *map_path, t_game *game_ptr)
{
	int		fd;
	int		line;
	char	**ret;

	line = get_y(map_path);
	ret = NULL;
	if (open(map_path, O_DIRECTORY) > 0)
		print_and_exit("Error\n file is needed.");
	fd = open(map_path, O_RDONLY);
	if (fd == -1)
		print_and_exit("Error\n Map file not found.");
	game_ptr->map_h = -1;
	while (++game_ptr->map_h < line)
	{
		game_ptr->map[game_ptr->map_h] = get_next_line(fd);
		del_nl(game_ptr->map[game_ptr->map_h]);
	}
	game_ptr->map_w = ft_strlen(game_ptr->map[0]);
	return (ret);
}

void	load_texture(t_game *game_ptr)
{
	game_ptr->exit = mlx_xpm_file_to_image(game_ptr->soft,
			"./ressources/image/exit.xpm", &game_ptr->height, &game_ptr->width);
	game_ptr->item = mlx_xpm_file_to_image(game_ptr->soft,
			"./ressources/image/item.xpm", &game_ptr->height, &game_ptr->width);
	game_ptr->p = mlx_xpm_file_to_image(game_ptr->soft,
			"./ressources/image/player.xpm", &game_ptr->height, &game_ptr->width);
	game_ptr->wall = mlx_xpm_file_to_image(game_ptr->soft,
			"./ressources//image/wall.xpm", &game_ptr->height, &game_ptr->width);
	game_ptr->floor = mlx_xpm_file_to_image(game_ptr->soft,
			"./ressources/image/floor.xpm", &game_ptr->height, &game_ptr->width);
}

int	item_nb(t_game *game_ptr)
{
	int	l;
	int	i;
	int	ret;

	l = 0;
	i = 0;
	ret = 0;
	while (l < game_ptr->map_h)
	{
		while (game_ptr->map[l][i])
		{
			if (game_ptr->map[l][i] == 'C')
				ret++;
			i++;
		}
		i = 0;
		l++;
	}
	return (ret);
}

int	move_player(int key, t_game *g)
{
	int		l;
	int		i;

	l = 0;
	i = 0;
	if (key == 2)
		return (move_right(g, key));
	if (key == 0)
		return (move_left(g, key));
	if (key == 1)
		return (move_down(g, key));
	if (key == 13)
		return (move_up(g, key));
	if (key == 53)
	{
		mlx_destroy_window(g->soft, g->win);
		print_and_exit("Goodbye thanks for playing \n");
	}
	return (0);
}

void	so_long(const char *map_path)
{
	t_game	game_ptr;

	get_map(map_path, &game_ptr);
	game_ptr.soft = mlx_init();
	check_map(&game_ptr);
	load_texture(&game_ptr);
	game_ptr.win = mlx_new_window(game_ptr.soft, game_ptr.map_w * 32,
			game_ptr.map_h * 32, "So_long");
	print_map(game_ptr);
	game_ptr.c_nbr = item_nb(&game_ptr);
	game_ptr.c_mv = 0;
	mlx_hook(game_ptr.win, 02, 0L, move_player, &game_ptr);
	mlx_hook(game_ptr.win, 17, 0, endgame, &game_ptr);
	mlx_loop(game_ptr.soft);
	return ;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: bgales <bgales@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2022/05/26 14:30:43 by bgales            #+#    #+#             */
/*   Updated: 2023/04/28 18:22:13 by bgales           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "so_long.h"


void	ber_check(const char *map)
{
	int	i;

	i = 0;
	while (map[i])
		i++;
	if (map[i - 1] != 'r' || map[i - 2] != 'e' || map[i - 3] != 'b'
		|| map[i - 4] != '.')
		print_and_exit("Missing \".ber\" in map file\n");
	return ;
}

int	main(int argc, char **argv)
{
	if (argc != 2)
	{
		print_and_exit("Arguments number is different than one\n");
		return (0);
	}
	ber_check(argv[1]);
	so_long(argv[1]);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   map_check.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: bgales <bgales@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2022/05/18 12:22:39 by bgales            #+#    #+#             */
/*   Updated: 2022/06/02 14:11:10 by bgales           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "so_long.h"

void	print_and_exit(char *str)
{
	ft_printf("%s", str);
	exit(0);
}

void	del_nl(char *str)
{
	int	i;

	i = -1;
	while (str[++i] != '\n')
		if (str[i] == '\0')
			break ;
	if (str[i] == '\n')
		str[i] = '\0';
}

void	print_map(t_game game_ptr)
{
	int	l;
	int	i;

	l = -1;
	i = -1;
	while (++l < game_ptr.map_h)
	{
		while (game_ptr.map[l][++i])
		{
			if (game_ptr.map[l][i] == '1')
				mlx_put_image_to_window(game_ptr.soft,
					game_ptr.win, game_ptr.wall, i * 32, l * 32);
			if (game_ptr.map[l][i] == 'P')
				mlx_put_image_to_window(game_ptr.soft,
					game_ptr.win, game_ptr.p, i * 32, l * 32);
			if (game_ptr.map[l][i] == 'C')
				mlx_put_image_to_window(game_ptr.soft,
					game_ptr.win, game_ptr.item, i * 32, l * 32);
			if (game_ptr.map[l][i] == 'E')
				mlx_put_image_to_window(game_ptr.soft,
					game_ptr.win, game_ptr.exit, i * 32, l * 32);
		}
		i = -1;
	}
	return ;
}

void	pce_check(t_game *game_ptr)
{
	t_chars	*check;

	check = malloc(sizeof(t_chars));
	ft_init(check);
	while (++check->line < game_ptr->map_h)
	{
		while (game_ptr->map[check->line][++check->i])
		{
			if (game_ptr->map[check->line][check->i] == 'P')
				check->p++;
			if (game_ptr->map[check->line][check->i] == 'C')
				check->c++;
			if (game_ptr->map[check->line][check->i] == 'E')
				check->e++;
		}
		check->i = -1;
	}
	if (check->p != 1)
		print_and_exit("Error\n one player is needed.");
	if (check->e != 1)
		print_and_exit("Error\n one exit is needed.");
	if (check->c < 1)
		print_and_exit("Error\n at least one item is needed.");
	free (check);
}

void	check_map(t_game *game_ptr)
{
	int		i;
	int		line;

	i = -1;
	line = -1;
	while (++line < (game_ptr->map_h))
		if (ft_strlen(game_ptr->map[line]) != game_ptr->map_w)
			print_and_exit("Error\n map is nor a square or rectangle.");
	while (game_ptr->map[0][++i] != '\0'
	|| game_ptr->map[game_ptr->map_h - 1][i] != '\0')
		if (game_ptr->map[0][i] != '1' ||
		game_ptr->map[game_ptr->map_h - 1][i] != '1')
			print_and_exit("Error\n Map is not surrounded by walls.");
	pce_check(game_ptr);
	return ;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   move.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: bgales <bgales@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2022/05/23 16:46:04 by bgales            #+#    #+#             */
/*   Updated: 2022/06/02 14:26:26 by bgales           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "so_long.h"

int	endgame(t_game *g)
{
	mlx_destroy_window(g->soft, g->win);
	ft_printf("Well played !\n");
	exit (0);
}

int	move_right(t_game *g, int key)
{
	int		l;
	int		i;

	l = -1;
	i = -1;
	while (++l < g->map_h)
	{
		while (g->map[l][++i] != '\0')
			if (g->map[l][i] == 'P')
				break ;
		if (g->map[l][i] == 'P' && (g->map[l][i + 1] == '0' || g->map[l][i + 1]
		== 'C' || (g->map[l][i + 1] == 'E' && g->c_nbr == 0)))
			move_right_norm(g, l, i, key);
		i = -1;
	}
	return (0);
}

int	move_left(t_game *g, int key)
{
	int		l;
	int		i;

	l = -1;
	i = -1;
	while (++l < g->map_h)
	{
		while (g->map[l][++i] != '\0')
			if (g->map[l][i] == 'P')
				break ;
		if (g->map[l][i] == 'P' && (g->map[l][i - 1] == '0' || g->map[l][i - 1]
		== 'C' || (g->map[l][i - 1] == 'E' && g->c_nbr == 0)))
			move_left_norm(g, l, i, key);
		i = -1;
	}
	return (0);
}

int	move_up(t_game *g, int key)
{
	int		l;
	int		i;

	l = 0;
	i = 0;
	while (l < g->map_h)
	{
		while (g->map[l][i] != '\0')
		{
			if (g->map[l][i] == 'P')
				break ;
			i++;
		}
		if (g->map[l][i] == 'P' && (g->map[l - 1][i] == '0'
		|| g->map[l - 1][i] == 'C' || (g->map[l - 1][i] == 'E'
		&& g->c_nbr == 0)))
			move_up_norm(g, l, i, key);
		l++;
		i = 0;
	}
	return (0);
}

int	move_down(t_game *g, int key)
{
	int		l;
	int		i;

	l = -1;
	i = -1;
	while (++l < g->map_h)
	{
		while (g->map[l][++i] != '\0')
			if (g->map[l][i] == 'P')
				break ;
		if (g->map[l][i] == 'P' && (g->map[l + 1][i] == '0' ||
			g->map[l + 1][i] == 'C'
		|| (g->map[l + 1][i] == 'E' && g->c_nbr == 0)))
		{
			move_down_norm(g, l, i, key);
			l++;
		}
		i = -1;
	}
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   move2.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: bgales <bgales@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2022/05/26 16:05:59 by bgales            #+#    #+#             */
/*   Updated: 2023/04/28 18:57:45 by bgales           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "so_long.h"
#include "ft_printf.h"

void	print_move(int key, t_game *g)
{
	char	*str;

	if (key == 2 || key == 0 || key == 1 || key == 13)
	{
		str = ft_itoa(g->c_mv);
		ft_printf("Move count : %d\n", g->c_mv);
		mlx_put_image_to_window(g->soft, g->win, g->wall, 0, 0);
		mlx_string_put(g->soft, g->win, 0, 0, 123, str);
		free (str);
	}
}

void	move_right_norm(t_game *g, int l, int i, int key)
{
	char	tmp;

	tmp = '\0';
	g->c_mv++;
	print_move(key, g);
	if (g->map[l][i + 1] == 'C')
		g->c_nbr--;
	if (g->c_nbr == 0 && g->map[l][i + 1] == 'E')
		endgame(g);
	mlx_put_image_to_window(g->soft, g->win, g->floor, i * 32, l * 32);
	mlx_put_image_to_window(g->soft, g->win, g->p, (i + 1) * 32, l * 32);
	tmp = g->map[l][i + 1];
	if (tmp == 'C')
		tmp = '0';
	g->map[l][i + 1] = g->map[l][i];
	g->map[l][i] = tmp;
}

void	move_left_norm(t_game *g, int l, int i, int key)
{
	char	tmp;

	tmp = '\0';
	g->c_mv++;
	print_move(key, g);
	if (g->map[l][i - 1] == 'C')
				g->c_nbr--;
	if (g->c_nbr == 0 && g->map[l][i - 1] == 'E')
		endgame(g);
	mlx_put_image_to_window(g->soft, g->win,
		g->floor, i * 32, l * 32);
	mlx_put_image_to_window(g->soft, g->win,
		g->p, (i - 1) * 32, l * 32);
	tmp = g->map[l][i - 1];
	if (tmp == 'C')
		tmp = '0';
	g->map[l][i - 1] = g->map[l][i];
	g->map[l][i] = tmp;
}

void	move_up_norm(t_game *g, int l, int i, int key)
{
	char	tmp;

	tmp = '\0';
	g->c_mv++;
	print_move(key, g);
	if (g->map[l - 1][i] == 'C')
				g->c_nbr--;
	if (g->c_nbr == 0 && g->map[l - 1][i] == 'E')
		endgame(g);
	mlx_put_image_to_window(g->soft, g->win, g->floor, i * 32, l * 32);
	mlx_put_image_to_window(g->soft, g->win, g->p, i * 32, (l - 1) * 32);
	tmp = g->map[l - 1][i];
	if (tmp == 'C')
		tmp = '0';
	g->map[l - 1][i] = g->map[l][i];
	g->map[l][i] = tmp;
}

void	move_down_norm(t_game *g, int l, int i, int key)
{
	char	tmp;

	tmp = '\0';
	g->c_mv++;
	print_move(key, g);
	if (g->map[l + 1][i] == 'C')
			g->c_nbr--;
	if (g->c_nbr <= 0 && g->map[l + 1][i] == 'E')
		endgame(g);
	mlx_put_image_to_window(g->soft, g->win, g->floor, i * 32, l * 32);
	mlx_put_image_to_window(g->soft, g->win, g->p, i * 32, (l + 1) * 32);
	tmp = g->map[l + 1][i];
	if (tmp == 'C')
		tmp = '0';
	g->map[l + 1][i] = g->map[l][i];
	g->map[l][i] = tmp;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: bgales <bgales@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/04/28 18:18:01 by bgales            #+#    #+#             */
/*   Updated: 2023/04/28 18:22:06 by bgales           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "so_long.h"

int	get_y(const char *map_path)
{
	char	*test;
	int		fd;
	int		ret;

	ret = 0;
	fd = open(map_path, O_RDONLY);
	test = get_next_line(fd);
	while (test)
	{
		ret++;
		free (test);
		test = get_next_line(fd);
	}
	free (test);
	return (ret);
}

void	ft_init(t_chars *z)
{
	z->p = 0;
	z->c = 0;
	z->e = 0;
	z->i = 0;
	z->line = -1;
}
